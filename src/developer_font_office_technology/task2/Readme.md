# Условия задачи
## Дано
- 18 758 328 телефонных номеров
- 18 758 328 полных имён пользователей
- средняя длина полного имени **20** символов
### нужно рассмотреть варианты
* поиск за постоянное время
* максимальная экономия памяти
 ## Решение
### Вариант 1 (PhoneBook.java)
Рассмотрим задачу на примере Java.
Телефонный номер может содержать цифры, знаки плюса и минуса, скобки и пробелы. Для простоты оценки, предположим, что каждый телефонный номер содержит только цифры и знак плюса или минуса для обозначения международного кода страны.

Таким образом, каждый телефонный номер будет занимать от 10 до 16 символов в зависимости от длины номера и наличия международного кода. С учетом размера символа char (2 байта), размер каждого телефонного номера в памяти будет составлять от 20 до 32 байт.

Если мы будем хранить 18 758 328 телефонных номеров в памяти в виде строк, то общий объем занимаемой памяти будет составлять от 375 166 560 до 600 266 496 байт, то есть от 358 до 573 мегабайт.

Также нам нужно сохранить все полные имена пользователей. Это ещё 358 мегабайт. 

### Вариант 2 (TrieNode.java , PhoneNumberTrie.java)
Снижаем скорость поиска и начинаем экономить память. Для этого подойдёт структура данных Trie (Prefix Tree).
Такая структура представляет собой дерево, в котором каждый узел соответствует префиксу ключа, а каждый путь от корня дерева до листового узла соответствует ключу.
Хранение номеров телефонов будет реализовано в виде двоичного дерева.
Для каждой цифры в номере телефона создается узел дерева. В конечном узле хранится полное имя клиента. При поиске номера телефона необходимо пройти по дереву, начиная от корня и двигаясь по ребрам, соответствующим цифрам номера. Если мы достигли конечного узла дерева, то мы нашли соответствующее имя клиента.
Экономия основа на том, что мы не не храним каждый ключ отдельно, а используем общие префиксы.

Мы проиграем в скорости поиска: поиск в дереве будет осуществляться за O(h) времени, где h - высота дерева. Скорость поиска будет зависеть от длины наиболее длинного номера телефона и количества узлов в дереве. Если дерево хорошо сбалансировано, то скорость поиска будет O(log n), где n - количество узлов в дереве.